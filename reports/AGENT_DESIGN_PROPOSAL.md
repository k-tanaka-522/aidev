# Agent設計提案書（再設計版）

**作成日**: 2025-10-24
**目的**: AIファシリテーターのAgent設計を深く考察し、実装可能な提案をまとめる

---

## 1. 重要な指摘の整理

### 1.1 ユーザーからの指摘

> 「ユーザーにいきなりアーキテクチャどうしますか？といってもわからん」

**問題点:**
- 技術用語でユーザーに質問しても、ユーザーは答えられない
- ユーザーの言葉で聞き、Agentが技術的な判断をする必要がある

**例:**

❌ **Bad（技術的な質問）:**
```
architect Agent: 「アーキテクチャはどれが良いですか？
1. マイクロサービス
2. モノリス
3. サーバーレス」
```

✅ **Good（ビジネス的な質問）:**
```
consultant Agent: 「将来的にユーザー数が急増する可能性はありますか？」
ユーザー: 「最初は100人、1年後に10,000人くらいになる予定です」
  ↓
consultant Agent（内部判断）:
  「ユーザー数が100倍に増加 → スケーラブルなアーキテクチャが必要」
  ↓
consultant Agent（ユーザーへの提案）:
  「ユーザー数が急増する想定なので、スケーラブルな設計を推奨します。
   具体的には、サービスごとに独立してスケールできる構成が良いと思います。
   この方向で進めて良いですか？」
```

### 1.2 既存のAIファシリテーターの内容を活かす

**既存のPHASE_GUIDE.mdの良い点:**
- ✅ ユーザーへの質問例が具体的
- ✅ 一問一答の原則
- ✅ ビジネス背景を最優先
- ✅ 事例・数値を重視
- ✅ 確認前の振り返り

**これを活かす方針:**
- PHASE_GUIDE.mdの内容をAgentのシステムプロンプトに組み込む
- Agentが「ユーザーへの質問例」を参照しながら対話

---

## 2. Claude Code Subagentの制約（調査結果）

### 2.1 ドキュメントで確認できたこと

1. ✅ **Agentの連鎖（chaining）は可能**
   - 複数のsubagentを順次実行できる
   - 例: code-analyzer → optimizer

2. ✅ **カスタムAgentの定義は可能**
   - `.claude/agents/` に配置
   - YAML frontmatter でname, description, tools を定義

3. ✅ **Claude が自動的にAgentを選択**
   - description フィールドで適切なAgentを判断

### 2.2 ドキュメントで不明な点（要検証）

1. ❓ **Agentの実行結果の受け取り方**
   - Agentが結果を返す際のフォーマット
   - メインのClaudeがどう受け取るか

2. ❓ **Agent間の階層的呼び出し**
   - 役割Agent（consultant）がプロセスAgent（initial-hearing）を呼び出せるか
   - Task toolをAgentが使えるか

3. ❓ **ユーザーとの対話委譲**
   - Agentがユーザーに質問を返せるか
   - メインのClaudeを経由する必要があるか

4. ❓ **Agentの自律的判断**
   - Agentが状況に応じて次のタスクを決められるか
   - プリプログラムされた選択しかできないか

### 2.3 実装前に検証すべきこと

**最小限のテスト:**
1. シンプルなAgentを1つ作成（`.claude/agents/test-agent.md`）
2. メインのClaudeからTask(test-agent)で呼び出し
3. Agentの実行結果を確認
4. Agentがユーザーに質問できるか確認
5. Agent内でTask toolが使えるか確認

---

## 3. Agent設計の選択肢（3パターン）

### パターンA: シンプル（役割Agentのみ、階層なし）

```
メインのClaude（PM）
  ↓
役割Agent 1: consultant（企画・要件定義担当）
  - PHASE_GUIDE.md（企画・要件定義）を読む
  - ユーザーと一問一答で進める
  - 企画書・要件定義書を生成
  - PMに報告
  ↓
役割Agent 2: architect（設計担当）
  - PHASE_GUIDE.md（設計）を読む
  - ユーザーと一問一答で進める
  - 基本設計書を生成
  - PMに報告
  ↓
役割Agent 3: coder（実装担当）
  - PHASE_GUIDE.md（実装）を読む
  - コード生成、テスト実行
  - PMに報告
```

**メリット:**
- ✅ シンプル（Agent数が少ない）
- ✅ 実装が簡単
- ✅ Claude Code Subagentの制約に対応しやすい

**デメリット:**
- ❌ 1つのAgentが複雑になる（PHASE_GUIDE.mdが長い）
- ❌ Agentのコンテキストが大きくなる（物忘れリスク）

---

### パターンB: 階層構造（役割Agent → プロセスAgent）

```
メインのClaude（PM）
  ↓
役割Agent: consultant
  ├─ プロセスAgent 1: initial-hearing
  ├─ プロセスAgent 2: problem-analysis
  ├─ プロセスAgent 3: goal-clarification
  └─ プロセスAgent 4: document-generator
  ↓
役割Agent: architect
  ├─ プロセスAgent 1: architecture-design
  ├─ プロセスAgent 2: system-design
  └─ プロセスAgent 3: document-generator
```

**メリット:**
- ✅ 各プロセスAgentが小さい（コンテキスト少ない）
- ✅ 役割Agentが全体をオーケストレーション
- ✅ プロセスAgentの再利用（document-generatorは共通）

**デメリット:**
- ❌ 階層的呼び出しが可能か不明（要検証）
- ❌ Agent数が多い（20-30個）
- ❌ 実装が複雑

**要検証項目:**
- 役割Agent内でTask toolを使ってプロセスAgentを呼び出せるか
- プロセスAgent → 役割Agent への結果返却の仕組み

---

### パターンC: ハイブリッド（メインが全部オーケストレーション）

```
メインのClaude（PM）
  ├─ プロセスAgent 1: initial-hearing
  ├─ プロセスAgent 2: problem-analysis
  ├─ プロセスAgent 3: goal-clarification
  ├─ プロセスAgent 4: architecture-design
  ├─ プロセスAgent 5: system-design
  └─ プロセスAgent 6: document-generator
```

**メリット:**
- ✅ 階層が1段階（シンプル）
- ✅ メインのClaudeが全体を管理（フロー制御が明確）
- ✅ 各プロセスAgentが小さい

**デメリット:**
- ❌ メインのClaudeの責務が大きい
- ❌ PHASE_GUIDE.mdの内容をメインが読む必要がある
- ❌ フェーズの概念が薄れる（プロセスAgentだけになる）

---

## 4. 推奨アプローチ（段階的実装）

### Phase 1: シンプルな役割Agent（パターンA）でテスト

**理由:**
- Claude Code Subagentの制約が不明確
- まずは実装可能な形でテスト
- 問題点を洗い出してから複雑化

**実装:**

```
.claude/agents/
├── consultant.md           # 企画・要件定義担当
├── architect.md            # 設計担当
├── coder.md                # 実装担当
└── qa.md                   # テスト担当
```

**consultant.md の内容例:**

```markdown
---
name: consultant
description: ビジネス背景・課題を深掘りし、企画書・要件定義書を生成するコンサルタント
tools:
  - Read
  - Write
  - Bash(git:*)
---

# コンサルタントAgent

## 役割

企画フェーズと要件定義フェーズを担当。ユーザーとの一問一答でビジネス背景・課題を深掘りし、企画書・要件定義書を生成する。

## 重要な原則

### 1. ユーザーの言葉で質問する

❌ 技術的な質問: 「アーキテクチャはどうしますか？」
✅ ビジネス的な質問: 「将来的にユーザー数が急増する可能性はありますか？」

### 2. 一問一答の原則

- 複数の質問を同時にしない
- 1つ聞いて → 回答待ち → 次を聞く
- ユーザーが疲れないように配慮

### 3. ビジネス背景を最優先

- 技術的な詳細より、「なぜ必要か」を深掘り
- 事例・数値を重視（抽象的な説明ではなく、具体的な数値）

### 4. 確認前の振り返り

- ドキュメント生成前に会話を振り返る
- 抜け漏れチェック
- 「もっといい提案」を準備

## 実行フロー

### 企画フェーズ

**参照**: `.claude/docs/10_facilitation/2.1_企画フェーズ/PHASE_GUIDE.md`

#### ステップ1: プロジェクト状態の確認

`.claude-state/project-state.json` を読み込み。

#### ステップ2: 初回ヒアリング

**ユーザーへの質問:**

> 「こんにちは！私はAI開発コンサルタントです。
> システム開発をお手伝いします。
>
> まず、何を作りたいか教えてください。
> どんなシステム・サービスを考えていますか？」

**重要**: 最初は広く聞く。詳細は後から深掘りする。

#### ステップ3: 課題の深掘り

**ユーザーへの質問:**

> 「『○○システム』を作りたいんですね。
>
> 具体的に、どんな課題を解決したいですか？
> 現状で困っていることを教えてください。」

**深掘りの質問:**

> 「その課題、具体的にどのくらいの頻度で発生していますか？
> 例えば、『毎日10件』『月に100件』など、数値で教えてください。」

#### ステップ4: 目的の明確化

**ユーザーへの質問:**

> 「この課題を解決することで、どんな効果を期待していますか？
>
> 例えば:
> - 売上向上: 月売上が○○円増加
> - コスト削減: 運用コストが○○%削減
> - 工数削減: 作業時間が○○時間削減
>
> など、数値で表すとどうなりますか？」

#### ステップ5: ターゲットユーザーの確認

**ユーザーへの質問:**

> 「このシステムを使うユーザーについて教えてください。
> 主に誰が使いますか？また、何人くらいのユーザーを想定していますか？」

#### ステップ6: 制約条件の確認

**ユーザーへの質問:**

> 「予算と納期について教えてください:
>
> 1. 予算はどのくらいを想定していますか？
>    - 初期費用: ○○万円
>    - 運用費用: 月○○万円
>
> 2. 納期はいつまでですか？
>    - 希望納期: ○○年○○月」

#### ステップ7: 確認前の振り返り

**ユーザーへの確認:**

> 「企画がほぼ固まりました。最後に振り返りをさせてください。
>
> **ビジネス背景:**
> - 課題: ○○
> - 解決策: ○○
>
> **システム化の目的:**
> - 目的: ○○
> - 効果: ○○
> - KPI: ○○
>
> **ターゲットユーザー:**
> - ○○
>
> **予算・納期:**
> - 初期費用: ○○万円
> - 運用費用: 月○○万円
> - 納期: ○○年○○月
>
> この内容で企画書を生成しても良いですか？
> または、追加で検討したいことはありますか？」

#### ステップ8: 企画書生成

企画書を `docs/01_企画書.md` に生成。

**参照**: `.claude/docs/10_facilitation/2.1_企画フェーズ/2.1.5_製造物_企画書構成.md`

#### ステップ9: プロジェクト状態の更新

`.claude-state/project-state.json` を更新:

```json
{
  "projectName": "プロジェクト名",
  "currentPhase": "requirements",
  "status": "ongoing",
  "completedPhases": ["planning"],
  "updatedAt": "ISO 8601"
}
```

#### ステップ10: PMへの報告

> 「企画フェーズが完了しました。
> 企画書を `docs/01_企画書.md` に生成しました。
>
> 次は要件定義フェーズに進みますか？
> または、企画書をレビューしますか？」

### 要件定義フェーズ

**参照**: `.claude/docs/10_facilitation/2.2_要件定義フェーズ/PHASE_GUIDE.md`

（企画フェーズと同様の流れ）

## 完了条件

- 企画書または要件定義書が生成された
- プロジェクト状態が更新された
- PMに報告した
```

**メリット:**
- ✅ PHASE_GUIDE.mdの内容を全てAgentに組み込める
- ✅ 一問一答の原則、ビジネス背景重視等の既存の良い点を活かせる
- ✅ Agentが自律的にフェーズ全体を実行

**デメリット:**
- ❌ Agentのプロンプトが長い（2000-3000行）
- ❌ Agentのコンテキストが大きい

---

### Phase 2: テスト結果を踏まえて改善

**Phase 1のテストで検証すべきこと:**

1. ✅ Agentがユーザーに質問できるか
2. ✅ Agentが一問一答を実行できるか
3. ✅ Agentが複数ステップを自律的に実行できるか
4. ✅ Agentの実行結果をメインのClaudeが受け取れるか
5. ✅ Agentのコンテキストサイズ制限（プロンプトが長すぎないか）

**改善方針:**
- コンテキストが大きすぎる → パターンB（階層構造）に移行
- 階層的呼び出しが可能 → プロセスAgentを分離
- 階層的呼び出しが不可 → パターンC（メインが全部オーケストレーション）

---

## 5. 実装計画

### 5.1 即座に実施すること

1. **Phase 1のテスト用Agentを1つ作成**
   - `.claude/agents/test-consultant.md`
   - 最小限の内容（初回ヒアリングのみ）
   - メインのClaudeから呼び出してテスト

2. **テスト項目の確認**
   - Agentがユーザーに質問できるか
   - Agentの実行結果をメインが受け取れるか
   - Agent内でTask toolが使えるか

3. **テスト結果をレポート**
   - 成功した項目
   - 失敗した項目
   - 制約・制限事項

### 5.2 テスト結果を踏まえた実装

**ケース1: 階層的呼び出しが可能**
- パターンB（役割Agent → プロセスAgent）を採用
- 役割Agentを4つ作成（consultant, architect, coder, qa）
- プロセスAgentを20-30個作成

**ケース2: 階層的呼び出しが不可**
- パターンA（役割Agentのみ）またはパターンC（メインがオーケストレーション）を採用
- PHASE_GUIDE.mdを参照しながら実装

### 5.3 段階的な機能追加

1. **Phase 1: 企画フェーズのみ実装**
   - consultant Agentを完成させる
   - 企画書生成までテスト

2. **Phase 2: 要件定義フェーズ追加**
   - consultant Agentに要件定義フェーズを追加
   - 要件定義書生成までテスト

3. **Phase 3: 設計フェーズ追加**
   - architect Agentを作成
   - 基本設計書生成までテスト

4. **Phase 4: 実装フェーズ追加**
   - coder Agentを作成
   - コード生成までテスト

---

## 6. ユーザーの言葉で質問するガイドライン

### 6.1 技術的な質問 → ビジネス的な質問への変換表

| 技術的な質問（❌ Bad） | ビジネス的な質問（✅ Good） | 判断の根拠 |
|---------------------|-------------------------|-----------|
| アーキテクチャはマイクロサービスとモノリスどちらが良いですか？ | 将来的にユーザー数が急増する可能性はありますか？ | ユーザー数急増 → スケーラブル → マイクロサービス |
| データベースはRDSとDynamoDBどちらが良いですか？ | データの整合性は厳密に保つ必要がありますか？それとも、多少の遅延は許容できますか？ | ACID保証必要 → RDS、結果整合性OK → DynamoDB |
| インフラはECS FargateとEC2どちらが良いですか？ | サーバー管理は自分たちでやりたいですか？それとも、管理不要の方が良いですか？ | 管理不要 → Fargate、自分で管理 → EC2 |
| 認証はOAuthとSAMLどちらが良いですか？ | ユーザーは既存のGoogle/Facebookアカウントでログインしたいですか？それとも、専用のアカウントを作成しますか？ | Google/Facebookログイン → OAuth、専用アカウント → SAML or ID/PW |

### 6.2 質問の流れ（例: アーキテクチャ設計）

```
consultant Agent:
  「将来的にユーザー数が急増する可能性はありますか？」
  ↓
ユーザー: 「最初は100人、1年後に10,000人くらいになる予定です」
  ↓
consultant Agent（内部判断）:
  「ユーザー数が100倍に増加 → スケーラブルなアーキテクチャが必要」
  ↓
consultant Agent:
  「ユーザー数が100人から10,000人に増加する想定ですね。

  この場合、システムの一部だけを拡張できる設計が良いと思います。
  例えば、ユーザー認証部分とデータ処理部分を分けておくと、
  データ処理が重くなった時に、データ処理部分だけを強化できます。

  この方向で進めて良いですか？」
  ↓
ユーザー: 「はい、お願いします」
  ↓
consultant Agent（内部判断）:
  「マイクロサービスアーキテクチャを採用」
```

---

## 7. まとめ

### 7.1 推奨アプローチ

**Phase 1: シンプルな役割Agent（パターンA）でテスト**
- consultant, architect, coder, qa の4つのAgentを作成
- PHASE_GUIDE.mdの内容を全てAgentのプロンプトに組み込む
- ユーザーの言葉で質問するガイドラインを組み込む
- 一問一答の原則を厳守

**Phase 2: テスト結果を踏まえて改善**
- 階層的呼び出しが可能 → パターンB（役割Agent → プロセスAgent）
- 階層的呼び出しが不可 → パターンA継続 or パターンC

### 7.2 重要な設計原則

1. **ユーザーの言葉で質問**
   - 技術用語を使わない
   - ビジネス的な質問に変換
   - Agentが内部で技術的な判断

2. **一問一答の原則**
   - 複数質問を同時にしない
   - 1つ聞いて → 回答待ち → 次へ

3. **既存のAIファシリテーターの内容を活かす**
   - PHASE_GUIDE.mdの質問例を活用
   - ビジネス背景を最優先
   - 事例・数値を重視
   - 確認前の振り返り

### 7.3 次のステップ

1. テスト用Agentを1つ作成（`.claude/agents/test-consultant.md`）
2. メインのClaudeから呼び出してテスト
3. テスト結果をレポート
4. テスト結果を踏まえて本格実装

---

**作成者**: Claude (Sonnet 4.5)
**作成日時**: 2025-10-24
