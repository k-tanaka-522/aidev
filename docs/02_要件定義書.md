# AI開発ファシリテーター 要件定義書

## 1. 概要

### 1.1 背景
開発プロセスにおいて、AIが技術標準を守らず、スパゲッティコードを生成したり、本番環境に直接操作を行うなどの問題が発生している。また、非エンジニアがシステム開発に参加する際、適切なプロセスとドキュメントがないため、品質や安全性に課題がある。

### 1.2 目的
自然言語での対話を通じて、標準化された開発プロセスをAIがファシリテートし、エンジニア・非エンジニアを問わず、誰でも高品質で安全なシステム開発を実現できる環境を提供する。

### 1.3 スコープ

#### Phase 1（初期実装）
- `.claude`設定ファイルによるローカル完結の仕組み
- 全開発フェーズ対応（企画→要件定義→設計→実装→テスト→デプロイ）
- 汎用的なシステム開発に対応（Webアプリ、API、インフラ、バッチ処理等）
- **初期検証ユースケース：AWS IaCプロジェクト**
- 単一プロジェクトでの運用

#### Phase 2以降（将来）
- MCP連携（Slack、Notion、GitHub等）
- 複数プロジェクト並行管理
- 既存インフラの解析・ドキュメント化
- 運用監視と自動復旧

---

## 2. ステークホルダー

### 2.1 主要ユーザー
1. **初期ユーザー（Phase 1）**
   - インフラエンジニア（AWS IaC構築・改修）
   - 本システムを実際に使用して検証

2. **展開先ユーザー（Phase 2）**
   - 周囲のエンジニア
   - 開発チーム全体

3. **最終ターゲット（Phase 3）**
   - 非エンジニアの事業会社担当者
   - 個人の起業家・アイデア保有者
   - 開発経験の浅いエンジニア
   - コンサルティングツールとしての活用

### 2.2 利用シーン

本システムは以下のような様々なシステム開発に対応：

1. **インフラ構築（IaC）**
   - クラウドインフラの構築・改修
   - 要件定義から設計、コード生成、デプロイまで
   - **Phase 1 検証対象：AWS（CloudFormation/Terraform）**
   - 将来的にGCP、Azure等にも対応

2. **Webアプリケーション開発**
   - フロントエンド（React、Vue、Angular等）
   - バックエンド（Node.js、Python、Java等）
   - フルスタック開発

3. **APIサーバー構築**
   - RESTful API
   - GraphQL API
   - マイクロサービス

4. **バッチ処理システム**
   - データ処理パイプライン
   - 定期実行ジョブ
   - ETL処理

5. **モバイルアプリ開発**（将来対応）
   - iOS、Android
   - クロスプラットフォーム

---

## 3. 機能要件

### 3.1 コミュニケーション機能

#### 3.1.1 対話型ヒアリング
- **一問一答形式**
  - 複数質問を同時にしない（ユーザーが疲れない）
  - 回答に応じて次の質問を選択
  - 会話の自然な流れを重視

- **段階的な情報収集**
  1. ビジネス背景（最優先）
     - 業種・業態
     - 現在の課題
     - なぜ今開発が必要なのか
     - レガシーからの移行 or 新規開発
  2. 技術要件（背景理解後）
     - システム構成
     - 規模・性能要件
     - セキュリティ・コンプライアンス

- **認識齟齬の防止**
  - 各フェーズ終了時に必ず確認
  - ビジュアル資料を活用
  - 曖昧な回答には追加質問
  - 決定事項の明示的な確認

#### 3.1.2 提案機能
- **「もっといい提案」の提供**
  - ユーザーの要望を否定しない
  - より良い選択肢を提示
  - 提案タイミング：会話の自然な切れ目、ユーザーの温度感を見て判断

- **プロとしての視点**
  - コスト最適化の提案
  - 将来の拡張性を考慮した設計提案
  - セキュリティリスクと対策の提示
  - パフォーマンス改善の提案

- **説明責任**
  - 提案理由を明確に説明
  - メリット・デメリットを提示
  - 非エンジニアにも分かる言葉で説明

#### 3.1.3 学習機会の提供
- 生成したコードの説明
- ベストプラクティスの解説
- 技術的判断の根拠を提示
- ユーザーが徐々に自力で書けるようになる支援

### 3.2 ドキュメント生成機能

#### 3.2.1 生成方針
- **受託開発納品レベルの品質**
- **フェーズごとの自動生成**
- **AIがプロアクティブに判断**して必要なドキュメントを生成

#### 3.2.2 ドキュメントの種類

##### 日本の受託開発レベルの品質

本システムは、日本企業の受託開発で求められるレベルのドキュメントを生成する。

**品質基準:**
- 納品時にそのまま使えるレベル
- 第三者が読んで理解できる
- 図・表を適切に活用
- フェーズごとに複数のドキュメントに分割（粒度を細かく）

##### ディレクトリ構成方針

各フェーズごとにディレクトリを分け、複数のドキュメントを生成：

```
docs/
├── 01_企画/
├── 02_要件定義/
├── 03_基本設計/
├── 04_詳細設計/
├── 05_実装/
├── 06_テスト/
├── 07_デプロイ/
└── 08_運用/
```

##### フェーズごとのドキュメント一覧

**1. 企画フェーズ (`docs/01_企画/`)**
- 企画書.md - ビジョン、目的、背景と課題、成功基準
- 提案書.md - RFP対応、ソリューション提案
- 費用見積書.md - 概算費用、内訳
- スケジュール.md - マイルストーン、工程表

**2. 要件定義フェーズ (`docs/02_要件定義/`)**
- 業務要件定義書.md - ビジネス背景、業務フロー、課題
- システム要件定義書.md - システム化範囲、システム構成
- 機能要件一覧.md - 機能ID、機能名、概要、優先度
- 非機能要件一覧.md - 性能、セキュリティ、可用性、保守性
- ユースケース記述.md - アクター、前提条件、基本フロー、代替フロー
- 画面一覧.md - 画面ID、画面名、概要（Webアプリの場合）
- 画面遷移図.md - Mermaid図（Webアプリの場合）
- データ項目定義.md - 項目名、型、必須/任意、説明

**3. 基本設計フェーズ (`docs/03_基本設計/`)**
- システム構成図.md - Mermaid図
- アーキテクチャ設計書.md - アーキテクチャパターン、技術スタック選定
- DB設計書.md - ER図（Mermaid）、テーブル定義
- インターフェース設計書.md - API一覧、外部システム連携
- セキュリティ設計書.md - 認証・認可、暗号化、脆弱性対策
- インフラ設計書.md - ネットワーク構成、サーバー構成（IaCの場合）

**4. 詳細設計フェーズ (`docs/04_詳細設計/`)**
- 機能別詳細設計/
  - 認証機能.md - 処理フロー、シーケンス図、データ構造
  - データ登録機能.md
  - （各機能ごとに作成）
- API設計書.md - エンドポイント、リクエスト/レスポンス、エラーコード
- バッチ設計書.md - バッチ一覧、実行タイミング、処理フロー（該当する場合）
- 画面設計書.md - ワイヤーフレーム、項目定義（Webアプリの場合）

**5. 実装フェーズ (`docs/05_実装/`)**
- コーディング規約.md - 命名規則、コメント規約、フォーマット
- ディレクトリ構成.md - ファイル配置ルール、モジュール構成
- セットアップ手順.md - 開発環境構築、依存関係インストール
- ビルド手順.md - ビルドコマンド、成果物

**6. テストフェーズ (`docs/06_テスト/`)**
- テスト計画書.md - テスト戦略、スコープ、スケジュール
- 単体テスト仕様書.md - テストケース一覧、期待値
- 結合テスト仕様書.md - テストシナリオ、データパターン
- システムテスト仕様書.md - E2Eテストシナリオ
- テスト結果報告書.md - 実施結果、不具合一覧、品質評価

**7. デプロイフェーズ (`docs/07_デプロイ/`)**
- リリース計画書.md - リリース日時、手順概要、リスク対策
- デプロイ手順書.md - 環境別デプロイ手順（dev/stg/prod）
- ロールバック手順書.md - 切り戻し手順、バックアップ戦略
- CI/CD設計書.md - パイプライン構成図、ブランチ戦略

**8. 運用フェーズ (`docs/08_運用/`)**
- 運用手順書.md - 日次/週次/月次作業、バックアップ手順
- 障害対応手順書.md - 障害レベル定義、エスカレーションフロー
- 監視設定書.md - 監視項目、アラート設定、閾値
- FAQ・トラブルシューティング.md - よくある問題と解決策

#### 3.2.3 ビジュアル資料の生成

##### 対応形式
- **Mermaid** - テキストベースの図（最優先）
  - システム構成図
  - CI/CDパイプライン図
  - ER図
  - シーケンス図
  - フロー図

- **DrawIO** - .drawio形式（将来対応）
- **PlantUML** - UML図（将来対応）
- **Figma連携** - UI/UXデザイン（ユーザー作成の共有）

##### AWS IaCで最優先の図
1. **システム構成図**
   - AWSサービスの配置
   - VPC、サブネット構成
   - セキュリティグループ
   - ロードバランサー、AutoScaling等

2. **CI/CDパイプライン図**
   - ソースコード管理（GitHub）
   - ビルド・テストプロセス
   - デプロイフロー
   - 承認フロー

3. **ネットワーク図**
   - VPC設計
   - サブネット分割
   - ルーティング
   - インターネットゲートウェイ、NATゲートウェイ

#### 3.2.4 ユーザー確認フロー
1. AIがヒアリングしながら情報収集
2. フェーズ終了時にドキュメント生成
3. **ユーザーに確認依頼**
   - ドキュメントの内容確認
   - 収集した情報の充足度確認
   - 次フェーズに進んで良いかの確認
4. 承認されたら次フェーズへ遷移
5. 承認されなかった場合
   - 追加ヒアリング実施
   - ドキュメント再生成
   - 再度確認依頼

### 3.3 タスク・課題・進捗管理機能

#### 3.3.1 タスク管理
- やるべきことの管理と追跡
- フェーズごとのタスク一覧
- タスクの優先順位付け
- 完了状況の記録

#### 3.3.2 課題管理
- 問題・リスクの把握
- 対応策の管理
- 課題の優先順位
- 解決状況の追跡

#### 3.3.3 進捗管理
- フェーズごとの進捗状況の可視化
- 全体進捗率の表示
- マイルストーン管理
- スケジュール遅延の検知

#### 3.3.4 未決定事項の追跡
- 決定保留事項の一覧
- 決定期限の管理
- 影響範囲の把握

### 3.4 コード生成機能

#### 3.4.1 対応技術領域（Phase 1）
- **AWS IaC** - CloudFormation または Terraform
- **CI/CD** - GitHub Actions
- **フロントエンド** - React/Vue等（基本対応）
- **バックエンド** - Node.js/Python等（基本対応）
- **データベース** - RDS、DynamoDB等

#### 3.4.2 技術標準・コード規約の適用

##### 4つの基本方針
1. **品質確保**
   - 保守可能なコード構造
   - 適切なモジュール分割
   - 技術的負債の最小化

2. **安全性確保**
   - 本番環境への直接操作禁止
   - 機密情報の適切な管理
   - 権限の最小化原則

3. **一貫性の維持**
   - コーディング規約の統一
   - 命名規則の標準化
   - ディレクトリ構造の統一

4. **ベストプラクティスの適用**
   - 各技術領域の推奨パターン
   - セキュリティ対策の標準化
   - パフォーマンスの最適化

##### 技術領域ごとの重点項目

**共通項目（全技術領域）**
1. **モジュール/コンポーネント分割**
   - 適切な粒度での分割
   - 再利用可能な設計
   - 責任の明確化

2. **環境差分の管理**
   - dev/stg/prodの差分を見やすく整理
   - 設定ファイルの構造化
   - シークレット情報の分離

3. **直感的な構成**
   - 誰が見ても分かるディレクトリ構造
   - 自己説明的な命名
   - 適切なコメント

**IaC（インフラ）特有**
- ネストテンプレート/モジュールの活用
- ステートファイル管理
- リソース命名規則

**Webアプリケーション特有**
- コンポーネント設計
- 状態管理の方針
- API連携のパターン

**バックエンド特有**
- レイヤーアーキテクチャ
- エラーハンドリング戦略
- ロギング・監視

#### 3.4.3 コード説明と学習支援
- 生成したコードの各部分の説明
- なぜこう書くのかの根拠
- ベストプラクティスの解説
- 改善ポイントの提示

### 3.5 デプロイ機能

#### 3.5.1 デプロイフロー（安全性重視）
1. **Dry-run（差分確認）**
   - 変更内容の表示
   - 影響範囲の確認
   - リスクの提示

2. **ユーザー承認**
   - 変更内容の確認
   - 実行タイミングの決定

3. **本番実行**
   - デプロイ実行
   - リアルタイムログ表示
   - エラーハンドリング

#### 3.5.2 デプロイ方法

**CI/CDツール（推奨）**
- **GitHub Actions** - 推奨
  - ブランチプッシュでトリガー
  - Pull Request でのレビュー
  - マージ後の自動デプロイ
- GitLab CI/CD
- CircleCI
- Jenkins

**手動実行（開発時・緊急時）**
- IaC：AWS CLI、Terraform CLI、gcloud等
- Webアプリ：ビルド→デプロイコマンド生成
- コマンド生成後、実行はユーザーが手動で

#### 3.5.3 環境戦略
- **環境分離**
  - dev（開発環境）
  - stg（ステージング環境）
  - prod（本番環境）

- **ブランチ戦略**
  - feature/* - 機能開発
  - develop - 開発統合
  - staging - ステージング
  - main - 本番

- **デプロイ順序**
  1. feature → develop → dev環境
  2. develop → staging → stg環境
  3. staging → main → prod環境（承認必須）

#### 3.5.4 ロールバック戦略
- **失敗検知**
  - デプロイエラーの自動検知
  - ヘルスチェック失敗の検知
  - アラート通知

- **ロールバック手順**
  1. 前バージョンの特定
  2. ロールバックコマンド生成
  3. ユーザー確認
  4. ロールバック実行

- **バックアップ戦略**
  - IaCの状態ファイル管理
  - データベースバックアップ
  - 設定ファイルのバージョン管理

### 3.6 エラーハンドリング・デバッグ支援

#### 3.6.1 エラーログ解析
- ログの自動収集
- エラーメッセージの解析
- 原因の特定
- 関連する設定・コードの特定

#### 3.6.2 修正方法の提案
- 具体的な修正手順の提示
- 修正コードの生成
- 複数の解決策の提案
- リスクと影響範囲の説明

#### 3.6.3 よくあるエラーの事前チェック
- デプロイ前のバリデーション
- 設定ミスの検出
- 権限不足の確認
- リソース制限のチェック

---

## 4. 非機能要件

### 4.1 パフォーマンス
- ドキュメント生成：30秒以内
- コード生成：1分以内
- エラー解析：10秒以内

### 4.2 ユーザビリティ
- **対話の自然さ**
  - 日本語での自然な対話
  - 適切な敬語の使用
  - 専門用語は説明を添える

- **わかりやすさ**
  - 非エンジニアでも理解できる説明
  - ビジュアル資料を活用
  - 段階的な情報提示

- **ストレスの軽減**
  - 一問一答形式
  - 回答の強制をしない
  - 後から変更可能

### 4.3 セキュリティ
- **機密情報管理**
  - AWSクレデンシャルの安全な管理
  - シークレット情報のハードコード禁止
  - 環境変数の適切な使用

- **本番環境保護**
  - 直接操作の禁止
  - dry-run必須
  - 承認フロー

- **権限管理**
  - 最小権限の原則
  - IAMロールの適切な設定
  - アクセス制御

### 4.4 保守性
- **コードの可読性**
  - 適切なコメント
  - 自己説明的な命名
  - モジュール化

- **ドキュメントの更新**
  - 変更時の自動更新
  - バージョン管理
  - 変更履歴の記録

- **拡張性**
  - 新しい技術への対応
  - プラグイン機構
  - カスタマイズ可能

### 4.5 可用性
- **エラー復旧**
  - エラー時の自動リカバリー
  - ロールバック機能
  - 詳細なログ記録

- **状態管理**
  - プロジェクト状態の永続化
  - 中断・再開の対応
  - 履歴の保存

---

## 5. 制約条件

### 5.1 技術的制約
- **Phase 1**
  - `.claude`設定ファイルのみで動作
  - ローカル環境で完結
  - Claude Codeの機能範囲内

- **外部ツール連携**
  - Phase 1ではMCP連携なし
  - Phase 2以降で段階的に追加

### 5.2 対応範囲の制約（Phase 1）
- **単一プロジェクトのみ**
  - 複数プロジェクト並行管理は Phase 2

- **既存インフラ解析**
  - Phase 2 以降で対応

### 5.3 予算制約
- Phase 1 は最小限の実装
- 実用性検証後に Phase 2 へ

### 5.4 期間制約
- Phase 1 の早期実用化を優先
- 初期検証ユースケース（AWS IaC）での実運用で検証
- 検証完了後、他の技術領域へ展開

---

## 6. 成功基準

### 6.1 Phase 1 の成功基準

1. **初期検証プロジェクト（AWS IaC）での実用**
   - 要件定義からデプロイまで完遂
   - 納品レベルのドキュメント生成
   - 安全なデプロイフロー
   - 他の技術領域にも適用可能な汎用性を確認

2. **コード品質**
   - スパゲッティコードにならない
   - 技術標準に準拠
   - 保守可能な構造
   - 技術領域に関わらず一貫した品質

3. **ユーザー満足度**
   - 対話がスムーズ
   - 疲れない（一問一答形式）
   - 学びがある（技術的成長）
   - エンジニア・非エンジニア両方が使える

4. **安全性**
   - 本番環境への誤操作ゼロ
   - シークレット漏洩ゼロ
   - dry-run必須の徹底

### 6.2 Phase 2 以降の目標
- 周囲のエンジニアへの展開
- MCP連携の実現
- コンサルツールとしての活用

---

## 7. 用語集

| 用語 | 説明 |
|------|------|
| IaC | Infrastructure as Code - インフラをコードで管理 |
| Dry-run | 実際には実行せず、変更内容のみ確認する機能 |
| ネストテンプレート | CloudFormationで、テンプレートを分割して管理する手法 |
| ロールバック | デプロイ失敗時に前のバージョンに戻すこと |
| MCP | Model Context Protocol - 外部ツール連携のプロトコル |

---

## 8. 付録

### 8.1 ヒアリング時の質問例

#### 8.1.1 共通質問（全プロジェクト）

**ビジネス背景**
1. どのような業種・業態ですか？
2. 現在どのような課題がありますか？
3. なぜ今この開発が必要ですか？
4. レガシーシステムからの移行ですか、新規開発ですか？

**システム要件**
5. どのようなシステム・アプリケーションを作りますか？
6. 想定するユーザー数・規模は？
7. 可用性の要件は？（ダウンタイム許容度）
8. セキュリティ要件は？（コンプライアンス等）
9. 予算・期間の制約はありますか？

**技術選定**
10. 使用したい技術・フレームワークはありますか？
11. 制約事項はありますか？（使えない技術、必須の技術等）
12. 既存システムとの連携はありますか？

#### 8.1.2 技術領域別の追加質問

**インフラ構築（IaC）の場合**
- IaCツールの希望は？（CloudFormation/Terraform/CDK等）
- クラウドプロバイダーは？（AWS/GCP/Azure）
- 既存インフラとの統合方法は？
- リージョン・AZ構成の要件は？

**Webアプリケーション開発の場合**
- フロントエンド/バックエンド/フルスタック？
- SPAですか、SSRですか？
- 認証方式は？（OAuth、JWT等）
- データの永続化は必要ですか？

**API開発の場合**
- RESTful API/GraphQL/gRPC？
- 認証・認可の方式は？
- レート制限は必要ですか？
- APIドキュメントの自動生成は必要ですか？

**バッチ処理の場合**
- 実行頻度は？（リアルタイム/定期実行/イベント駆動）
- データソースは？
- エラー時のリトライ戦略は？
- 処理結果の通知は必要ですか？

---

## 9. 実運用フィードバックに基づく追加要件

### 9.1 背景

Phase 1の初期実装をもとに、実際のプロジェクト（介護保険申請管理システム）で使用した結果、以下の課題が明らかになった。

### 9.2 課題1: 新規プロジェクト初期化の問題

#### 問題点

**A. aiDev自体のドキュメントが残る**
- `git clone`後、`docs/`にaiDev自体の企画書・要件定義書・設計書が残る
- ユーザーの新規プロジェクトと混在してしまう

**B. git originがaidevリポジトリを向いたまま**
- `git clone`すると、originがaidevリポジトリを指したまま
- ユーザーが誤ってaidevにpushしてしまうリスク

**C. 未追跡ファイルの混在**
- 新規プロジェクトでcloneすると、aiDev由来の未追跡ファイルが残る可能性

#### 解決策（要件）

**初期化スクリプトの提供**

```bash
# Windows
.\scripts\init-new-project.bat

# Mac/Linux
./scripts/init-new-project.sh
```

**スクリプトが実行する処理:**
1. `.git/` ディレクトリを削除（git履歴をクリーン）
2. `docs/` の中身を削除（.gitkeep は残す）
3. `.claude-state/project-state.json` を初期状態にリセット
4. `git init` で新規リポジトリ化
5. 初回コミットを作成
6. 「新規プロジェクトとして初期化しました」と表示

**README.mdの修正**
- パターンA（新規プロジェクト）の手順に、初期化スクリプトの実行を追加
- スクリプトの実行内容を明記

**aiDev自体のドキュメントの移動**
- `docs/` → `.claude/docs/examples/` または別ディレクトリ
- READMEで「このシステムの開発過程は `.claude/docs/examples/` を参照」と案内

### 9.3 課題2: CloudFormation構造のわかりにくさ

#### 問題点

**A. ファイル構成が不明瞭**
- `shared/network.yaml` と `shared/templates/network.yaml` の2つが存在
- READMEのデプロイ手順と実装が不一致
  - README: `shared/network.yaml` を直接デプロイ
  - 実装: `main.yaml`が親で、`templates/`配下をネスト呼び出し

**B. S3バケットが必須だが、手順に記載なし**
- ネストスタックはS3経由で子テンプレートを参照
- `main.yaml`の76行目: `https://${TemplatesBucketName}.s3...`
- ユーザーが事前にS3バケット作成＋テンプレートアップロードが必要
- **READMEにこの手順が記載されていない**

**C. ネスト階層の複雑さ**
- 親スタックから子スタックへのパラメータ受け渡しが冗長
- `main.yaml`の99-107行目: ConnectivityStackに8個のパラメータを渡す記述

**D. ディレクトリ名が直感的でない**
- `templates/` という名前では、何のテンプレートか不明
- ネストスタックの子テンプレートであることが分かりにくい

#### 解決策（要件）

**案B採用: ネスト構造を維持 + 改善**

1. **ディレクトリ構造の改善**

```
infra/shared/
├── stack.yaml                    # 親スタック（main.yaml → stack.yamlにリネーム）
├── nested/                       # templates/ → nested/ にリネーム
│   ├── network.yaml              # VPC, IGW, Subnet
│   └── connectivity.yaml         # TGW, Client VPN
├── parameters-poc.json
└── deploy.sh                     # デプロイスクリプト（新規）
```

**命名の改善:**
- `main.yaml` → `stack.yaml` (より明確)
- `templates/` → `nested/` (ネストスタックであることが明確)
- 重複する `shared/network.yaml` は削除

2. **デプロイスクリプトの提供**

`infra/shared/deploy.sh` の内容:
```bash
#!/bin/bash
# 使い方: ./deploy.sh poc

ENVIRONMENT=$1
BUCKET_NAME="careapp-cfn-templates-${ENVIRONMENT}"

echo "=== CareApp Shared Network Stack Deployment ==="
echo "Environment: ${ENVIRONMENT}"

# 1. S3バケット作成（存在しない場合）
echo "[1/3] Checking S3 bucket..."
aws s3 mb s3://${BUCKET_NAME} 2>/dev/null || echo "Bucket already exists"

# 2. ネストテンプレートをS3にアップロード
echo "[2/3] Uploading nested templates to S3..."
aws s3 cp nested/network.yaml s3://${BUCKET_NAME}/shared/nested/
aws s3 cp nested/connectivity.yaml s3://${BUCKET_NAME}/shared/nested/

# 3. 親スタックをデプロイ
echo "[3/3] Deploying CloudFormation stack..."
aws cloudformation create-stack \
  --stack-name CareApp-${ENVIRONMENT}-SharedNetwork \
  --template-body file://stack.yaml \
  --parameters file://parameters-${ENVIRONMENT}.json \
  --capabilities CAPABILITY_IAM

echo "=== Deployment initiated. Check AWS Console for progress. ==="
```

Windows版 `deploy.bat` も同様に提供。

3. **README.mdの修正**

デプロイ手順を以下に変更:
```bash
# 共有系ネットワークスタック
cd infra/shared
./deploy.sh poc    # または deploy.bat poc (Windows)
```

S3バケットの事前準備が不要（スクリプトが自動処理）

4. **技術標準への追加**

`.claude/docs/40_standards/42_infrastructure.md` に以下を追記:

**CloudFormationネストスタックの命名規則:**
- 親スタック: `stack.yaml`
- 子テンプレート格納ディレクトリ: `nested/`
- 子テンプレート: 機能単位で命名（`network.yaml`, `connectivity.yaml`等）

**ディレクトリ構造の標準:**
```
infra/{component}/
├── stack.yaml              # 親スタック（エントリーポイント）
├── nested/                 # ネストスタックの子テンプレート
│   ├── xxx.yaml
│   └── yyy.yaml
├── parameters-{env}.json   # 環境別パラメータ
└── deploy.sh               # デプロイスクリプト
```

### 9.4 課題3: タスク・進捗管理機能が動いていない

#### 問題点

- `.claude-state/` ディレクトリが生成されていない
- プロジェクト状態が記録されていない
- タスク管理（`tasks.json`）が存在しない
- 引継ぎ用の状態管理がない

#### 影響

- セッションをまたいだ継続ができない
- 進捗が見えない
- 何をやったか履歴が残らない
- チーム内での引継ぎができない

#### 解決策（要件）

**3.3.5 状態管理の自動生成（NEW）**

**要件:**
- プロジェクト開始時に`.claude-state/`を自動生成
- フェーズ遷移時に`project-state.json`を自動更新
- 重要な決定事項を`decisions.json`に自動記録
- セッション開始時、既存の状態を自動読み込み

**自動生成タイミング:**
1. ユーザーが初めて会話を始めた時
2. フェーズが遷移した時
3. 重要な決定（技術選定等）がされた時
4. コード生成が完了した時
5. デプロイが完了した時

**ファイル構造:**
```
.claude-state/
├── project-state.json      # プロジェクト全体の状態
├── tasks.json              # タスク一覧
├── decisions.json          # 意思決定記録
└── history/                # 履歴
    ├── sessions/           # セッション履歴
    └── error-logs/         # エラーログ
```

**動作:**
- AIは自動で `.claude-state/project-state.json` を読み込み、前回の続きから再開
- `/status` コマンドでプロジェクト全体の状態を可視化

### 9.5 課題4: レビュー・確認タスクの自動生成がない

#### 問題点

- コード生成後、レビュータスクが自動で作られない
- 「確認してください」という指示はあるが、タスクとして記録されない
- 承認フローが曖昧
- レビュー観点が不明確

#### 解決策（要件）

**3.3.6 レビュータスクの自動生成（NEW）**

**要件:**
- コード生成完了後、自動でレビュータスクを作成
- レビュー観点を明示（チェックリスト形式）
- 承認/非承認の記録
- 非承認時の修正フローの明確化

**レビュータスクの内容例（CloudFormationの場合）:**

```markdown
## レビュータスク: CloudFormationテンプレート

### チェックリスト
- [ ] テンプレートの構造が理解できるか
- [ ] パラメータファイルの値が正しいか
- [ ] リソース命名規則に従っているか
- [ ] 環境差分（dev/stg/prod）が適切に管理されているか
- [ ] セキュリティグループの設定が適切か
- [ ] dry-run（変更セット）を実行したか
- [ ] 変更内容に問題がないか

### 次のアクション
- 承認 → デプロイフェーズへ
- 非承認 → 修正内容をフィードバック
```

**自動生成タイミング:**
1. CloudFormationテンプレート生成後
2. アプリケーションコード生成後
3. ドキュメント生成後
4. 設定ファイル生成後

**動作:**
- AIが自動でレビュータスクを `tasks.json` に追加
- ユーザーが `/tasks` コマンドでタスク一覧を確認
- チェックリストを確認しながらレビュー
- 承認/非承認を記録

### 9.6 課題5: `.claude`を最初に見てくれない問題

#### 問題点

- プロジェクト開始時、「.claude見て」と明示的に指示しないと、`.claude/docs/`を読んでくれなかった
- CLAUDE.mdに「参照すべき」とは書いてあるが、強制力がない
- Claudeが自発的に読むには、もっと明示的な指示が必要

#### 解決策（要件）

**CLAUDE.mdの冒頭に強制的な指示を追加**

```markdown
# AI開発ファシリテーター

**⚠️ 重要: 必ず最初にこれを読んでください**

あなた（Claude）は、このプロジェクトで会話を始める際、**必ず以下のファイルを読んでください**：

1. **`.claude/docs/00_core-principles.md`** - 最重要：基本原則と行動指針
2. **`.claude-state/project-state.json`** - プロジェクトの現在の状態

これらを読まずに会話を始めることは**禁止**です。

---

## このプロジェクトについて
...
```

**追加の対策:**

`.claude/settings.json` にプロンプトを追加:
```json
{
  "systemPrompt": "あなたはAI開発ファシリテーターです。会話開始時、必ず `.claude/docs/00_core-principles.md` と `.claude-state/project-state.json` を読んでから応答してください。"
}
```

### 9.7 追加要件: 引継ぎ機能

#### 要件

**セッションをまたいだ継続性**
- プロジェクト状態の永続化
- セッション開始時の自動復帰
- 「前回の続きから」が自然にできる

**プロジェクト状態の可視化**
- `/status` コマンドで全体把握
- 完了・進行中・未着手の明確化
- 課題・ブロッカーの一覧表示

**引継ぎドキュメントの自動生成**
- セッション終了時、自動で引継ぎメモを生成
- 次のセッション開始時に表示
- 「前回はここまで進みました」

---

## 10. 承認

本要件定義書の内容（追加要件含む）を確認し、次のフェーズ（設計）に進むことに同意します。

- 承認日：________
- 承認者：________