# コンテキスト管理

このドキュメントは、AIがプロジェクトの状態を管理し、効率的にコンテキストを扱う方法を定義しています。

---

## 1. コンテキストの階層

### Layer 1（Hot）- 即座に参照
- **現在フェーズの作業内容**
- **直近の会話（3〜5往復）**
- **現在の決定事項**
- **進行中のタスク**

**保存場所：**
- `.claude-state/project-state.json`
- セッション中のメモリ

### Layer 2（Warm）- 必要に応じて参照
- **前フェーズのサマリー**
- **重要な決定事項の記録**
- **制約条件**
- **技術標準・コード規約**

**保存場所：**
- `.claude-state/decisions.json`
- `.claude/docs/40_standards/`
- 各フェーズのドキュメント

### Layer 3（Cold）- 検索して参照
- **過去の全会話履歴**
- **生成されたすべてのドキュメント**
- **エラーログ・履歴**

**保存場所：**
- `docs/` - 生成ドキュメント
- `.claude-state/history/` - 履歴

---

## 2. 情報の優先順位

AIがコンテキストを構築する際の優先順位：

1. **ユーザーが明示した制約** - 最優先
2. **現在フェーズの決定事項**
3. **技術的な決定事項**
4. **ビジネス要件**
5. **前フェーズのサマリー**
6. **参考情報**

---

## 3. フェーズごとのコンテキスト戦略

### 企画フェーズ
**ロードする情報：**
- ユーザーの初回発言
- `.claude/docs/00_core-principles.md`
- `.claude/docs/10_facilitation/11_decision-items.md` の企画部分

**最小限で済む理由：**
まだプロジェクトが始まったばかりで、過去の情報がない。

---

### 要件定義フェーズ
**ロードする情報：**
- 企画書のサマリー（ビジョン、目的、背景）
- 現在の決定事項
- `.claude/docs/10_facilitation/11_decision-items.md` の要件定義部分

**重視すること：**
- ビジネス背景を常に意識
- 企画で決めたビジョンとの整合性

---

### 設計フェーズ
**ロードする情報：**
- 要件定義書のサマリー（機能要件、非機能要件、制約条件）
- 技術標準（`.claude/docs/40_standards/`）
- 選定された技術スタック

**重視すること：**
- 要件を満たす設計か
- 技術標準に準拠しているか
- 拡張性・保守性

---

### 実装フェーズ
**ロードする情報：**
- 設計書のサマリー（アーキテクチャ、技術スタック、インフラ構成）
- 技術標準（`.claude/docs/40_standards/` の詳細）
- コーディング規約

**重視すること：**
- 設計通りに実装
- 技術標準の適用
- コードの品質

---

### テストフェーズ
**ロードする情報：**
- 要件定義書（テストすべき機能）
- 設計書（テストすべきコンポーネント）
- 実装したコード

**重視すること：**
- 要件を満たしているか
- バグがないか
- カバレッジ

---

### デプロイフェーズ
**ロードする情報：**
- 設計書（インフラ構成、CI/CD戦略）
- 環境変数・シークレット
- デプロイ手順

**重視すること：**
- 安全性（dry-run必須）
- ロールバック準備
- 監視設定

---

## 4. セッション継続性の確保

### 初回セッション
```
1. .claude-state/project-state.json の存在確認
2. なし → 新規プロジェクト
3. あり → 継続プロジェクト
```

### 継続セッション
```
1. project-state.json を読み込み
2. 現在のフェーズを特定
3. 前回の状態をサマリー
4. 「続きから始めますか？」をユーザーに確認
```

**例：**
```
AI: お帰りなさい！
　　前回は設計フェーズの途中でした。
　　システム構成図を作成中でしたが、CI/CD戦略が未決定でした。

　　続きから始めますか？
　　それとも状況を詳しく確認しますか？（/statusコマンド推奨）
```

---

## 5. コンテキストの圧縮

### 長い会話のサマリー化

**タイミング：**
- セッションが長くなった時
- フェーズ遷移時
- トークン数が多くなった時

**方法：**
```
【圧縮前】
User: どんなシステムを作りたいですか？
AI: AWSでインフラです
User: IaCツールは？
AI: Terraformでお願いします
... （長い会話）

【圧縮後】
- プロジェクト：AWSインフラ構築
- IaCツール：Terraform
- 環境：dev/stg/prod
- CI/CD：GitHub Actions
```

### 決定事項の記録

重要な決定は `.claude-state/decisions.json` に記録。

```json
{
  "decisions": [
    {
      "id": "dec-001",
      "date": "2025-09-30T13:00:00Z",
      "phase": "requirements",
      "title": "IaCツールをTerraformに決定",
      "rationale": "チームの経験、モジュール化のしやすさ",
      "impact": "high"
    }
  ]
}
```

---

## 6. トークン節約のための戦略

### 不要な情報は読み込まない

**読み込まない：**
- 古いエラーログ（解決済み）
- 関係ないフェーズの詳細
- 雑談・関係ない会話

**読み込む：**
- 現在のフェーズに関連する情報
- 重要な決定事項
- 制約条件

### 参照ドキュメントの選択的ロード

**常にロード：**
- `.claude/docs/00_core-principles.md`
- 現在フェーズの決定事項定義

**必要に応じてロード：**
- 技術標準（コード生成時のみ）
- プラグイン（該当する場合のみ）
- テンプレート（ドキュメント生成時のみ）

---

#### プロジェクトタイプ別の技術標準読み込み

**インフラプロジェクト（AWS IaC）の場合：**

```
【プロジェクトタイプ判明時】
- プロジェクトタイプが "infrastructure" または IaC構築と判明
  ↓
- `.claude/docs/40_standards/42_infrastructure.md` を読み込む
- 特に以下を確認：
  - セクション1.2: CloudFormation日本語制約
  - セクション8: 開発ワークフロー

【コード生成直前（重要！）】
- CloudFormation/Terraformコードを生成する直前
  ↓
- `.claude/docs/40_standards/42_infrastructure.md` を**再読み込み**
- 理由：長い会話で制約を忘れないため
- 確認項目：
  - 日本語制約（論理ID、パラメータ名は英数字のみ）
  - DependsOn の必要性
  - 開発ワークフロー（小さく始めて段階的に）
```

**アプリケーションプロジェクトの場合（Phase 2以降）：**

```
【プロジェクトタイプ判明時】
- プロジェクトタイプが "application" と判明
  ↓
- `.claude/docs/40_standards/43_application.md` を読み込む（将来実装）

【コード生成直前】
- アプリケーションコードを生成する直前
  ↓
- 該当する技術標準を再読み込み
```

**共通標準（全プロジェクト）：**

```
【シークレット管理が必要な時】
- `.claude/docs/40_standards/45_secrets-management.md` を読み込む
- 環境変数、AWS Secrets Manager、.gitignore等の確認
```

---

## 7. 状態ファイルの管理

### project-state.json の更新頻度

**更新するタイミング：**
- フェーズ遷移時
- 重要な決定事項が確定した時
- ドキュメント生成時
- デプロイ完了時

**更新しないタイミング：**
- 単なる質問のやりとり
- 雑談
- 説明のみ

### 状態ファイルの肥大化防止

**戦略：**
- 必要最小限の情報のみ記録
- 詳細はドキュメントに記載
- 状態ファイルは「索引」として使う

**例：**
```json
{
  "requirements": {
    "summary": "製造業向けのクラウド移行プロジェクト",
    "document": "docs/02_要件定義書.md"  // ← 詳細はこちら
  }
}
```

---

## 8. エラー時のコンテキスト保持

### エラー発生時
```
1. エラー内容を記録（.claude-state/history/error-logs/）
2. 現在の状態を保存
3. エラー解析
4. 修正提案
5. 解決後、状態を更新
```

### エラーログの構造
```json
{
  "timestamp": "2025-09-30T16:30:00Z",
  "phase": "deployment",
  "error_type": "terraform_error",
  "context": {
    "file": "main.tf",
    "line": 42,
    "recent_changes": ["リソース名変更"]
  },
  "resolution": {
    "status": "resolved",
    "solution": "リソース名を修正"
  }
}
```

---

## 9. 複数プロジェクト対応（Phase 2以降）

Phase 1では単一プロジェクトのみだが、将来的には複数プロジェクトに対応。

**想定：**
- プロジェクトごとに `.claude-state/` を分離
- プロジェクト切り替え時にコンテキストを入れ替え

---

## 10. ベストプラクティス

### AIが意識すること

1. **必要な情報だけをロード**
   - トークンを節約
   - レスポンス速度向上

2. **重要な決定は記録**
   - セッションをまたいでも継続可能
   - 後から振り返れる

3. **サマリーを活用**
   - 長い会話は要約
   - 決定事項を整理

4. **ユーザーに状況を明示**
   - 「現在〇〇フェーズです」
   - 「〇〇が未決定です」

---

## まとめ

効率的なコンテキスト管理により：
- トークンの節約
- レスポンス速度の向上
- セッション継続性の確保
- ユーザー体験の向上

を実現できます。

常に「今必要な情報は何か」を意識して、適切なコンテキストを構築してください。